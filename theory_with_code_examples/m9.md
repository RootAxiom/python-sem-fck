# M9: Text Files in Python

### Text files store data as human-readable characters (e.g., .txt, .csv, .log), making them simple for configuration, logs, or data exchange. Python's built-in `open()` function handles file I/O with modes for reading, writing, and more. Files are streams: data read/written sequentially, with a cursor tracking position. Always manage files carefully to avoid data loss or leaksâ€”use context managers like `with`.

### Best practices: Specify encoding (e.g., `encoding='utf-8'`) for non-ASCII; handle exceptions (e.g., `FileNotFoundError`); close files explicitly or via `with`.

## Opening a Text File
Use `open(filename, mode='r', encoding=None)` to open. Returns a file object (handle) for operations.
- **Filename**: Path (relative or absolute, e.g., "data.txt").
- **Mode**: String specifying intent (detailed next).
- **Encoding**: Handles text decoding (default system; use 'utf-8' for portability).

**Example**:
```python
# Open existing file for reading
file_handle = open("example.txt", "r", encoding="utf-8")
content = file_handle.read()  # Read all
print(content)
file_handle.close()  # Always close!
```

**Notes**:
- Opens in text mode by default (binary: 'b' suffix, e.g., "rb").
- Relative paths: From script's directory.

## Text File Open Modes
Modes control access: read-only, write, etc. Combine with 't' (text, default) or 'b' (binary). Can't read/write simultaneously unless mixed modes.

| Mode | Description | Behavior if File Exists | Behavior if File Doesn't Exist | Cursor Start |
|------|-------------|--------------------------|--------------------------------|--------------|
| **'r'** | Read (default) | Opens for reading | Error: `FileNotFoundError` | Beginning |
| **'r+'** | Read and write | Opens for both | Error: `FileNotFoundError` | Beginning |
| **'w'** | Write | Truncates to empty | Creates new file | Beginning |
| **'w+'** | Write and read | Truncates and allows read | Creates new | Beginning |
| **'a'** | Append | Opens for writing at end | Creates new | End |
| **'a+'** | Append and read | Allows read/write at end | Creates new | End |

**Example**:
```python
# 'r': Read only
with open("example.txt", "r") as f:
    print(f.read())

# 'w': Write (overwrites)
with open("output.txt", "w") as f:
    f.write("Hello, World!")

# 'a': Append
with open("output.txt", "a") as f:
    f.write("\nAppended line.")

# 'r+': Read/write
with open("output.txt", "r+") as f:
    content = f.read()  # Read
    f.seek(0)  # Reset cursor
    f.write("Modified: " + content)  # Write from start
```

**Notes**:
- 'w'/'a' for output; 'r' for input.
- Mixed modes ('r+', 'w+', 'a+') allow both but cursor management needed.

## Closing a Text File
Call `file.close()` to flush buffers, release resources, and free locks. Omitting causes leaks or data loss.
- Always close after use.

**Example**:
```python
f = open("example.txt", "r")
content = f.read()
f.close()  # Explicit close
print("File closed:", f.closed)  # True
```

**Error Risk**:
```python
# Bad: No close (data may not flush)
f = open("example.txt", "w")
f.write("Unsaved?")
# f.close()  # Forgotten!
```

**Check**: `f.closed` returns True if closed.

## Opening a File Using with Clause
The `with` statement (context manager) auto-opens and closes files, even on errors. Handles exceptions gracefully.
- **Syntax**: `with open(filename, mode) as alias:`
- RAII-like: `__enter__` on open, `__exit__` on close.

**Example**:
```python
# Safer reading
with open("example.txt", "r", encoding="utf-8") as f:
    content = f.read()
    print(content)
# f auto-closed here

# Nested
with open("input.txt", "r") as infile, open("output.txt", "w") as outfile:
    outfile.write(infile.read().upper())
```

**Benefits**:
- No explicit `close()`.
- Exception-safe: Closes on `Ctrl+C` or errors.

**Notes**:
- Use for all file ops; PEP 343 standard.

## Writing/Appending Data to a Text File Using write() and writelines()
- **`write(string)`**: Writes single string (no auto-newline). Returns bytes written.
- **`writelines(iterable)`**: Writes iterable of strings (no auto-newlines/joins).

**Example - write()**:
```python
with open("output.txt", "w") as f:
    f.write("First line\n")  # Explicit \n
    f.write("Second line\n")

# Append mode
with open("output.txt", "a") as f:
    f.write("Appended line\n")
```

**Example - writelines()**:
```python
lines = ["Line 1\n", "Line 2\n", "Line 3\n"]
with open("output.txt", "w") as f:
    f.writelines(lines)  # Writes as-is

# Without \n in iterable
lines_no_nl = ["Line A", "Line B"]
with open("output.txt", "a") as f:
    f.writelines(line + "\n" for line in lines_no_nl)
```

**Notes**:
- `write()`: For single ops; O(len(string)).
- `writelines()`: Efficient for lists; no separator added.
- Buffering: Flushes on close or `f.flush()`.

## Reading from a Text File Using read(), readline() and readlines()
- **`read(size=-1)`**: Reads all (or up to bytes) as string. Returns '' on EOF.
- **`readline(size=-1)`**: Reads one line (includes \n). Returns '' on EOF.
- **`readlines(hint=-1)`**: Reads all lines into list. Hint: Approx lines.

**Example**:
```python
with open("example.txt", "r") as f:
    # All content
    all_text = f.read()  # "Line1\nLine2\n..."
    print(all_text)

    f.seek(0)  # Reset for next

    # One line
    line1 = f.readline()  # "Line1\n"
    print(repr(line1))  # Shows \n

    # All lines
    lines = f.readlines()  # ['Line1\n', 'Line2\n']
    print(lines[0].strip())  # Line1 (remove \n)
```

**Incremental Reading**:
```python
with open("large.txt", "r") as f:
    while True:
        chunk = f.read(1024)  # 1KB chunks
        if not chunk:
            break
        print(chunk, end='')  # Process chunk
```

**Notes**:
- `read()`: For whole files; memory-intensive for large.
- `readline()`: Line-by-line (slow for many lines).
- `readlines()`: List for small files; use generator `for line in f:` instead.
- Strip whitespace: `line.strip()`.

## seek and tell Methods
Manage file cursor (position in bytes for text).
- **`tell()`**: Returns current byte position (int).
- **`seek(offset, whence=0)`**: Moves cursor.
  - `whence=0`: Absolute from start.
  - `1`: Relative to current.
  - `2`: From end.

**Example**:
```python
with open("example.txt", "r+") as f:
    print(f.tell())  # 0 (start)

    f.seek(5)  # Move to byte 5
    print(f.tell())  # 5
    mid_content = f.read(10)  # Reads from pos 5

    f.seek(0, 2)  # End
    print(f.tell())  # File length

    # Write from position
    f.seek(0)
    f.write("New start")
```

**Notes**:
- Text mode: Byte offsets approximate (UTF-8 variable).
- Binary mode: Exact bytes.
- Use for random access (e.g., logs).

##  Manipulation of Data in a File
Read, modify in memory (e.g., list/dict), write back. For large files: Process line-by-line to save RAM.

**Example - Simple Replace**:
```python
# Read all lines
with open("input.txt", "r") as f:
    lines = f.readlines()

# Modify
lines = [line.replace("old", "new") for line in lines]
lines[0] = "Modified first line\n"  # Edit specific

# Write back
with open("output.txt", "w") as f:
    f.writelines(lines)
```

**Line-by-Line (Memory-Efficient)**:
```python
# Copy with filter (e.g., lines containing "keyword")
with open("input.txt", "r") as infile, open("filtered.txt", "w") as outfile:
    for line in infile:
        if "keyword" in line:
            outfile.write(line.upper())  # Transform and write
```

**Advanced - CSV Manipulation** (Use `csv` module for robustness):
```python
import csv
with open("data.csv", "r") as f:
    reader = csv.reader(f)
    data = list(reader)  # Read to list

data[1][2] = "Updated"  # Modify row 1, col 2

with open("updated.csv", "w", newline="") as f:
    writer = csv.writer(f)
    writer.writerows(data)
```

**Use Cases**:
- Logs: Append timestamps.
- Config: Read dict, update, write JSON.
- Data Cleaning: Filter/sort lines.

**Notes**:
- Atomic writes: Use temp file + rename to avoid corruption.
- Errors: Handle `IOError`, backup originals.

