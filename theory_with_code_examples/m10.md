# M10: Classes and Objects in Python

Classes and objects form the backbone of Object-Oriented Programming (OOP) in Python, enabling code organization, reusability, and modeling real-world entities. A **class** is a blueprint or template defining attributes (data) and methods (behavior). An **object** (instance) is a concrete realization of a class, with its own state. Python's OOP is dynamic: classes are objects too (everything is an object), supporting introspection and metaprogramming.

Python supports all four OOP pillars: Encapsulation, Inheritance, Polymorphism, and Abstraction. Classes are defined with the `class` keyword and can be extended for complex hierarchies.

## Features of OOPs Programming
OOP organizes code around objects rather than functions/procedures, promoting modularity and maintainability. Key features (pillars):

| Feature       | Description                                                                 | Python Example Benefit |
|---------------|-----------------------------------------------------------------------------|------------------------|
| **Encapsulation** | Bundles data (attributes) and methods; hides internals using private vars (convention: `_var` or `__var`). | Protects data; e.g., bank account balance not directly accessible. |
| **Inheritance** | Child classes inherit from parents, reusing code. | Reduces duplication; e.g., `Dog` inherits `Animal` behaviors. |
| **Polymorphism** | Same interface (method name) behaves differently per class. | Flexible code; e.g., `speak()` as "Woof" for Dog, "Meow" for Cat. |
| **Abstraction** | Hides complexity, exposes essentials (e.g., via abstract classes). | Simplifies usage; e.g., user calls `drive()` without knowing engine details. |

**Additional Python OOP Traits**:
- **Dynamic Typing**: Attributes/methods added at runtime.
- **Multiple Inheritance**: Inherit from multiple parents.
- **Duck Typing**: "If it walks like a duck..."—focus on behavior, not type.

## Creation of Class
Define a class with `class ClassName:`, followed by indented body. Class names use CamelCase (PEP 8).
- Body: Attributes (class-level) and methods.
- `pass`: Placeholder for empty class.

**Example**:
```python
class Car:  # Define class
    """
    A simple Car class.
    """
    pass  # Empty body

# Create object (instance)
my_car = Car()  # Instantiation
print(type(my_car))  # <class '__main__.Car'>
print(isinstance(my_car, Car))  # True
```

**Notes**:
- Each instance has unique state but shares methods.
- Docstrings: First string in class for documentation (`help(Car)`).

## self Variable
`self` is a convention (not keyword) for the first parameter in instance methods, referring to the current object. It enables access to instance attributes/methods.
- Implicitly passed on call (e.g., `obj.method()` → `Method(obj)`).
- Use `self.attr` for instance data.

**Example**:
```python
class Person:
    def greet(self):  # self required
        print(f"Hello, I'm {self.name}!")  # Access instance attr

p = Person()
p.name = "Alice"  # Set attr
p.greet()  # Hello, I'm Alice!  (calls greet(p))
```

**Without self** (Error):
```python
class Bad:
    def greet():  # No self
        print("Hi")

b = Bad()
b.greet()  # TypeError: greet() takes 0 args, 1 given
```

**Notes**:
- Can name differently (e.g., `this`), but `self` is standard.
- For class methods: Use `cls` (below).

## Constructor
The `__init__` method (dunder) is the constructor: Called automatically on instantiation to initialize state.
- Takes `self` + parameters.
- No explicit return (returns `None`).

**Example**:
```python
class Person:
    def __init__(self, name, age):  # Constructor
        self.name = name  # Instance attr
        self.age = age
        print(f"Created {self.name}")

p = Person("Bob", 25)  # Calls __init__(p, "Bob", 25)
print(p.name, p.age)  # Bob 25
```

**Default Constructor**:
```python
class Empty:
    def __init__(self):
        pass  # No params needed

e = Empty()  # OK
```

**Notes**:
- Can raise exceptions for validation (e.g., `if age < 0: raise ValueError`).
- Other dunders: `__str__` for print, `__repr__` for debug.

## Types of Variable
Variables in classes have scopes: Instance (per-object), Class (shared), Static (method-local, but class-related).

| Type              | Scope/Access                  | Definition                          | Example Use |
|-------------------|-------------------------------|-------------------------------------|-------------|
| **Instance**     | Per object (`self.var`)      | Set in `__init__` or methods       | Unique data (e.g., `self.balance`) |
| **Class**        | Shared across instances (`Class.var`) | Defined in class body              | Constants (e.g., `Car.wheels = 4`) |
| **Static/Local** | Method-local (implicit)      | In methods, not prefixed           | Temp vars in computations |

**Example**:
```python
class BankAccount:
    bank_name = "MyBank"  # Class var (shared)

    def __init__(self, owner, balance=0):
        self.owner = owner  # Instance var
        self.balance = balance

    def deposit(self, amount):
        temp = amount * 1.01  # Local var
        self.balance += temp

acc1 = BankAccount("Alice", 100)
acc2 = BankAccount("Bob", 200)
acc1.deposit(50)

print(acc1.balance)  # 150.5
print(acc2.balance)  # 200
print(acc1.bank_name, acc2.bank_name)  # MyBank MyBank (shared)
BankAccount.bank_name = "NewBank"  # Changes for all
```

**Notes**:
- Access class vars via instance or class.
- Modifying class var via instance affects all.

## Namespace
A namespace is a mapping of names to objects (like a dict). Classes/objects have `__dict__` attributes for their namespace.
- **Class Namespace**: Shared methods/attrs.
- **Instance Namespace**: Unique per object.
- Global/Module: Outer scopes.

**Example**:
```python
class Example:
    class_var = 42  # In class __dict__

    def __init__(self):
        self.inst_var = "hello"  # In instance __dict__

e = Example()
print(Example.__dict__)  # Dict with 'class_var', '__init__', etc.
print(e.__dict__)  # {'inst_var': 'hello'}
print(Example.__name__)  # 'Example' (class name)
```

**Notes**:
- Use `getattr(obj, 'attr', default)` for dynamic access.
- `__dict__` modifiable: `e.__dict__['new'] = 1`.

## Types of Methods
Methods define object behavior. Three types based on first param and decorator.

| Type             | Decorator/First Param | Accesses          | Use Case |
|------------------|-----------------------|-------------------|----------|
| **Instance**    | None (`self`)        | Instance & class | Object-specific (e.g., `deposit()`) |
| **Class**       | `@classmethod` (`cls`) | Class only      | Factory methods, shared state |
| **Static**      | `@staticmethod` (none) | Neither         | Utilities (e.g., validators) |

**Example**:
```python
class MathUtils:
    class_var = "Math"  # Shared

    def instance_method(self, x):  # Instance
        return x + self.class_var  # Access class via self

    @classmethod
    def class_method(cls, y):  # Class
        return f"{cls.class_var}: {y}"  # Access via cls

    @staticmethod
    def static_method(z):  # Static
        return z ** 2  # No self/cls

# Usage
mu = MathUtils()
print(mu.instance_method(5))  # 5Math
print(MathUtils.class_method(10))  # Math: 10  (or mu.class_method(10))
print(MathUtils.static_method(3))  # 9
```

**Notes**:
- Instance: Most common.
- Class: For alternatives to constructors (e.g., `from_string(cls, s):`).
- Static: Like module functions, but grouped.

## Inheritance: Constructor in Inheritance, super()
Inheritance lets child (`subclass`) extend parent (`superclass`). Child inherits attrs/methods; can override.
- Syntax: `class Child(Parent):`
- **Constructor in Inheritance**: Child's `__init__` calls parent's via `super().__init__()` to initialize inherited state.
- **`super()`**: Refers to superclass; dynamic for multiple inheritance.

**Example**:
```python
class Animal:  # Parent
    def __init__(self, species):
        self.species = species

    def speak(self):
        print("Some sound")

class Dog(Animal):  # Child
    def __init__(self, name, breed):  # Child constructor
        super().__init__("Canine")  # Call parent
        self.name = name
        self.breed = breed

    def speak(self):  # Override
        print("Woof!")

d = Dog("Buddy", "Labrador")
print(d.species)  # Canine (inherited)
d.speak()  # Woof! (overridden)
```

**Notes**:
- Without `super()`: Parent not initialized (e.g., `species` undefined).
- `super()` args: `super(Dog, self).__init__()` (explicit, but `super()` suffices).

## Types of Inheritance
Python supports flexible inheritance models.

| Type              | Description                          | Example |
|-------------------|--------------------------------------|---------|
| **Single**       | One parent.                         | `Dog(Animal)` |
| **Multiple**     | Multiple parents (diamond issue possible). | `Amphibian(Frog, Toad)` |
| **Multilevel**   | Chain: A → B → C.                   | `Puppy(Dog(Animal))` |
| **Hierarchical** | One parent, multiple children.      | `Dog(Animal)`, `Cat(Animal)` |
| **Hybrid**       | Mix (e.g., multilevel + multiple).  | Complex trees |

**Multiple Inheritance Example**:
```python
class Flyer:
    def fly(self):
        print("Flying")

class Swimmer:
    def swim(self):
        print("Swimming")

class Duck(Flyer, Swimmer):  # Multiple
    pass

duck = Duck()
duck.fly()  # Flying
duck.swim()  # Swimming
```

**Notes**:
- Order matters (MRO below).
- Avoid deep multiples to prevent complexity.

## Method Resolution Order (MRO)
In multiple inheritance, MRO defines lookup order for methods/attrs. Python uses C3 linearization: Depth-first, left-to-right, no cycles.
- View: `Class.mro()` or `Class.__mro__`.
- Ensures each parent appears once.

**Example**:
```python
class A:
    def method(self):
        print("A")

class B(A):
    pass

class C(A):
    def method(self):
        print("C")

class D(B, C):  # MRO: D -> B -> C -> A
    pass

print(D.mro())  # [<class 'D'>, <class 'B'>, <class 'C'>, <class 'A'>, <class 'object'>]
d = D()
d.method()  # C (from C, after B but B inherits A's; C overrides)
```

**Notes**:
- `object`: Base for all classes.
- Conflicts: First in MRO wins.

## Polymorphism
Polymorphism allows objects of different classes to be treated uniformly via shared interfaces. Achieved via method overriding or duck typing.

**Example (Overriding)**:
```python
class Bird:
    def move(self):
        print("Flying")

class Fish:
    def move(self):
        print("Swimming")

def make_move(animal):  # Polymorphic function
    animal.move()  # Same call, different behavior

bird = Bird()
fish = Fish()
make_move(bird)  # Flying
make_move(fish)  # Swimming
```

**Duck Typing**:
```python
# No inheritance needed
class Robot:
    def move(self):
        print("Rolling")

make_move(Robot())  # Rolling (works if has move())
```

**Notes**:
- Enables generic code (e.g., lists of mixed types).

## Operator and Method Overloading
Overload operators (`+`, `==`) and methods by defining special (dunder) methods. Makes classes behave like built-ins.

**Example - Operator Overloading**:
```python
class Point:
    def __init__(self, x, y):
        self.x, self.y = x, y

    def __add__(self, other):  # +
        return Point(self.x + other.x, self.y + other.y)

    def __eq__(self, other):  # ==
        return self.x == other.x and self.y == other.y

    def __str__(self):  # print()
        return f"({self.x}, {self.y})"

p1 = Point(1, 2)
p2 = Point(3, 4)
p3 = p1 + p2  # Calls __add__
print(p3)  # (4, 6)
print(p1 == Point(1, 2))  # True
```

**Method Overloading** (Python doesn't support true overload by signature; use defaults/*args):
```python
class Calculator:
    def add(self, a, b, c=0):  # Default for 2/3 args
        return a + b + c

calc = Calculator()
print(calc.add(1, 2))  # 3
print(calc.add(1, 2, 3))  # 6
```

**Notes**:
- Common: `__len__`, `__getitem__` for list-like.
- Avoid overusing; clarify intent.

## Abstract Class and Interface
Abstract classes enforce structure: Can't instantiate; subclasses must implement abstract methods. Python uses `abc` module.
- **Abstract Class**: Partial implementation + abstracts.
- **Interface**: Pure abstract (all methods abstract; Python approximation).

**Example**:
```python
from abc import ABC, abstractmethod

class Shape(ABC):  # Abstract base
    @abstractmethod
    def area(self):  # Must implement
        pass

    @abstractmethod
    def perimeter(self):
        pass

    def description(self):  # Concrete method
        return "A shape"

class Rectangle(Shape):  # Concrete subclass
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):  # Implements abstract
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)

# Shape()  # TypeError: Can't instantiate abstract
rect = Rectangle(5, 3)
print(rect.area())  # 15
print(rect.description())  # A shape (inherited)
```

**Interface Simulation**:
```python
class Drawable(ABC):  # "Interface"
    @abstractmethod
    def draw(self):
        pass
```

**Notes**:
- `@abstractmethod`: Raises error if not overridden.
- Use `isinstance(obj, AbstractClass)` for checks.
- Mixins: Small classes for multiple inheritance (e.g., `Serializable`).

