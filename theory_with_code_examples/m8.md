#  M8: Dictionaries in Python

### Dictionaries (dicts) are mutable, unordered (but insertion-ordered since Python 3.7), hashable-key collections that store key-value pairs. Keys must be immutable (e.g., strings, numbers, tuples) and unique; values can be anything (mutable or not). Dicts are ideal for lookups (O(1) average time), mappings (e.g., JSON-like data), and counting (e.g., word frequencies). Defined with curly braces `{}`, they use colons `:` for pairs and commas for separation.

Internally, dicts use hash tables for fast access. They support methods for manipulation, iteration, and views (dynamic snapshots).

## Creating Dictionary
Create dicts using curly braces `{}` with key-value pairs or the `dict()` constructor.
- **Syntax**: `my_dict = {key1: value1, key2: value2}`
- Keys: Hashable, unique. Values: Any type.

**Example**:
```python
# Basic dict with mixed value types
person = {"name": "Alice", "age": 30, "city": "NYC", "hobbies": ["reading", "coding"]}

# Numeric keys (less common)
coords = {0: (10, 20), 1: (30, 40)}

print(person)  # {'name': 'Alice', 'age': 30, 'city': 'NYC', 'hobbies': ['reading', 'coding']}
```

**Notes**:
- Order preserved since 3.7 (insertion order).
- Use dict comprehension: `{k: v for k, v in zip(keys, values)}`.

## Empty Dictionary
An empty dict has no pairs and serves as a starting point for dynamic building.
- **Syntax**: `empty_dict = {}` or `dict()`

**Example**:
```python
empty = {}
print(empty)  # {}
print(len(empty))  # 0
print(bool(empty))  # False (empty dicts are falsy)
```

**Use Case**: Initialize for accumulation, e.g., `word_count = {}` then `word_count[word] += 1`.

#### Add Key:Value Pair in Dictionary
Add or update by assigning to a key. If key exists, updates value; else, adds pair.
- O(1) average time.

**Example**:
```python
person = {"name": "Alice", "age": 30}
person["email"] = "alice@example.com"  # Add new
person["age"] = 31  # Update existing

print(person)  # {'name': 'Alice', 'age': 31, 'email': 'alice@example.com'}
```

**Notes**:
- For multiple: Use `update()` (below).

#### Use of dict()
The `dict()` constructor creates from iterables of pairs, keyword args, or other dicts.
- **Syntax**: `d = dict(iterable_of_pairs)` or `dict(key=value, ...)`

**Example**:
```python
# From list of tuples
pairs = [("a", 1), ("b", 2)]
d1 = dict(pairs)  # {'a': 1, 'b': 2}

# From keyword args
d2 = dict(name="Bob", age=25)  # {'name': 'Bob', 'age': 25}

# From another dict
d3 = dict(original_dict)
```

**Notes**:
- Iterable must yield (key, value) pairs.
- Keywords auto-stringify keys.

##  Specify Value Pair Separately in Sequence
Create by passing sequences (lists/tuples) of keys and values via `dict.fromkeys()` or zipping.
- `fromkeys(keys, default_value)`: Sets all keys to same value (shallow copy of default).

**Example**:
```python
# fromkeys
keys = ["apple", "banana", "cherry"]
fruits = dict.fromkeys(keys, "fruit")  # {'apple': 'fruit', 'banana': 'fruit', 'cherry': 'fruit'}

# Zip sequences
names = ["Alice", "Bob"]
ages = [30, 25]
people = dict(zip(names, ages))  # {'Alice': 30, 'Bob': 25}
```

**Notes**:
- `fromkeys()` with mutable default (e.g., `[]`) shares reference—use `None` and set later.
- `zip()` stops at shortest sequence.

##  Add Elements to Dictionary
Beyond assignment, use `update()` to add/merge from another dict, iterable of pairs, or kwargs.
- Merges/overrides existing keys.

**Example**:
```python
person = {"name": "Alice"}
extras = {"age": 30, "city": "NYC"}

person.update(extras)  # Adds both
person.update(age=31, job="Engineer")  # Updates age, adds job

print(person)  # {'name': 'Alice', 'age': 31, 'city': 'NYC', 'job': 'Engineer'}
```

**From Iterable**:
```python
person.update([("email", "alice@example.com"), ("hobby", "coding")])
```

**Notes**:
- In-place; O(len(updates)) time.
- Python 3.9+: `person |= extras` (merge operator).

## Check Existence of a Key in Dictionary
Use `in` operator for membership (keys only). O(1) time.
- `key in dict`: True if exists.

**Example**:
```python
person = {"name": "Alice", "age": 30}
print("name" in person)  # True
print("email" in person)  # False

# Negative
print("salary" not in person)  # True
```

**Alternatives**:
- `dict.get(key)` returns None if missing (no error).
- `key in dict.keys()` (redundant, but explicit).

## get(), items(), keys(), values()
These methods provide access and views (dynamic, reflect changes).

- **`get(key, default=None)`**: Returns value or default (no KeyError). O(1).
- **`items()`**: View of (key, value) tuples. Iterable.
- **`keys()`**: View of keys. Iterable.
- **`values()`**: View of values. Iterable.

**Example**:
```python
person = {"name": "Alice", "age": 30, "city": "NYC"}

# get
print(person.get("age"))  # 30
print(person.get("email", "No email"))  # "No email"

# items
for key, value in person.items():
    print(f"{key}: {value}")  # name: Alice \n etc.

# keys
print(list(person.keys()))  # ['name', 'age', 'city']

# values
print(list(person.values()))  # ['Alice', 30, 'NYC']
```

**Notes**:
- Views are not lists—convert with `list()`.
- `get()` safer than `dict[key]` for optional keys.

## len()
Returns number of key-value pairs. O(1).
- **Syntax**: `length = len(my_dict)`

**Example**:
```python
print(len(person))  # 3
print(len({}))  # 0
```

**Use Case**: Check emptiness: `if len(d) > 0:` or `if d:` (truthy if non-empty).

## fromkeys()
Creates new dict from iterable of keys, optional default value (all set to it).
- Covered under "Specify Value Pair Separately".

**Example Recap**:
```python
tags = dict.fromkeys(["urgent", "important"], 1)  # {'urgent': 1, 'important': 1}
```

##  Extend/Update Dictionary with New Value
Use `update()` to extend (add new) or override. Same as "Add Elements".
- Merges dicts or iterables.

**Example Recap** (from earlier):
```python
d = {"a": 1}
d.update({"b": 2, "a": 3})  # Extends b, updates a to 3
```

**Notes**:
- For single: Assignment `d[key] = value`.
- Bulk: `update()` preferred.

## Making Shallow Copy of Dictionary
Create independent copy with `copy()` or `{**d}` (unpack). Shallow: Copies pairs but shares mutable values.
- Use `copy.deepcopy()` for deep (recursive).

**Example**:
```python
original = {"name": "Alice", "scores": [90, 85]}
shallow = original.copy()  # or dict(original) or {**original}

shallow["name"] = "Bob"  # original unchanged
shallow["scores"].append(95)  # original affected: [90, 85, 95]

import copy
deep = copy.deepcopy(original)
deep["scores"].append(100)  # original unchanged
```

**Notes**:
- `copy()`: O(n) time.
- Shallow sufficient if values immutable.

## Delete Elements from Dictionary (clear(), pop(), popitem(), del)
Remove pairs with these methods. In-place.

- **`clear()`**: Empties dict.
- **`pop(key, default=None)`**: Removes and returns value (default if missing).
- **`popitem()`**: Removes and returns last (arbitrary pre-3.7) pair as (key, value).
- **`del dict[key]`**: Deletes key (KeyError if missing).

**Example**:
```python
person = {"name": "Alice", "age": 30, "city": "NYC"}

# pop
age = person.pop("age")  # 30; person={'name':'Alice','city':'NYC'}
missing = person.pop("job", "Not found")  # "Not found"; person unchanged

# popitem
last_pair = person.popitem()  # ('city', 'NYC'); person={'name':'Alice'}

# del
del person["name"]  # person={}

# clear
person.clear()  # person={}
```

**Notes**:
- `popitem()` LIFO since 3.7 (last inserted).
- For slices: No direct; iterate and del.

## max(), min(), sum()
Apply to keys/values if comparable. Views iterable.
- **`max(dict)`**: Max key (or `max(dict.values())` for values).
- **`min(dict)`**: Min key/value similarly.
- **`sum(dict)`**: Sums keys (or `sum(values())`).

**Example**:
```python
nums = {1: "one", 3: "three", 2: "two"}
print(max(nums))  # 3 (max key)
print(max(nums.values()))  # "two" (lex max value, strings)

print(min(nums))  # 1
print(sum(nums))  # 6 (sum keys)

# Values numeric
scores = {"Alice": 90, "Bob": 85}
print(sum(scores.values()))  # 175
print(max(scores, key=scores.get))  # "Alice" (max value key)
```

**Notes**:
- Mixed types: `TypeError`.
- Use `key` arg for custom: `max(d, key=d.get)` for max-value key.
- Empty: `ValueError`.
