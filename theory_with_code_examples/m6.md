# M6: Lists in Python

### Lists are one of Python's most versatile built-in data structures, representing ordered, mutable collections of items. They can hold elements of any type (integers, strings, objects, even other lists), making them ideal for dynamic arrays, queues, or stacks. Lists are defined using square brackets `[]` and are zero-indexed. Their mutability allows in-place modifications, which is efficient but requires care to avoid unintended changes.

### Lists support a wide range of operations, including indexing, slicing, and methods for manipulation. They are implemented as dynamic arrays under the hood, with O(1) average append time but occasional resizing.

## Creation of List
Create lists using square brackets `[]`, separating elements with commas. Elements can be of mixed types.
- **Syntax**: `my_list = [element1, element2, ...]`
- Lists can be created from scratch or by converting other iterables.

**Example**:
```python
# Basic list with mixed types
fruits = ["apple", "banana", 42, 3.14, True]

# List of integers
numbers = [1, 2, 3, 4, 5]

# Empty list (covered next)
empty = []
```

**Notes**:
- No limit on size (memory permitting).
- Commas are optional after the last element (trailing comma).
- Use list comprehension for concise creation: `[x**2 for x in range(5)]` → `[0, 1, 4, 9, 16]`.

#### Empty List
An empty list contains no elements and is useful as a starting point for building lists dynamically (e.g., via appends).
- **Syntax**: `empty_list = []`

**Example**:
```python
empty_list = []
print(empty_list)  # []
print(len(empty_list))  # 0
print(bool(empty_list))  # False (empty lists are falsy)
```

**Use Case**: Initialize for user input or data accumulation.
```python
user_inputs = []  # Start empty
while True:
    inp = input("Enter value (or 'quit'): ")
    if inp == 'quit':
        break
    user_inputs.append(inp)
```

#### Nested List
A nested list (or list of lists) allows hierarchical data storage, like matrices or multi-dimensional arrays.
- Create by including lists as elements.

**Example**:
```python
# 2D nested list (matrix)
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# Deeper nesting
nested_deep = [[1, [2, 3]], [4, 5]]

print(matrix[1][2])  # 6 (row 1, column 2)
```

**Accessing Nested Elements** (detailed later under indexing/slicing):
- Use multiple indices: `outer_list[outer_index][inner_index]`.
- For deeper nests: `list[0][0][1]`.

**Use Case**: Representing grids, like a chessboard: `board = [['R', 'N', ...], ...]`.

#### Use of list()
The `list()` constructor converts other iterables (strings, tuples, sets, ranges) into lists. It's explicit and useful for type conversion.
- **Syntax**: `new_list = list(iterable)`

**Example**:
```python
# From string
chars = list("hello")  # ['h', 'e', 'l', 'l', 'o']

# From tuple
tup = (1, 2, 3)
num_list = list(tup)  # [1, 2, 3]

# From range
evens = list(range(0, 10, 2))  # [0, 2, 4, 6, 8]

# From set (order not guaranteed pre-Python 3.7)
s = {3, 1, 2}
ordered = list(s)  # [3, 1, 2] (arbitrary order)
```

**Notes**:
- `list()` on non-iterables raises `TypeError`.
- Efficient for one-time conversions; avoid in loops.

#### Accessing List
Access elements by index using square brackets `[]`. Lists are zero-indexed (first element at 0, last at -1 for negative indexing).
- **Syntax**: `element = my_list[index]`
- Out-of-bounds access raises `IndexError`.

**Example**:
```python
fruits = ["apple", "banana", "cherry"]
print(fruits[0])  # apple (first)
print(fruits[-1])  # cherry (last)
print(fruits[1])  # banana (middle)
```

**Negative Indexing**:
- `-1`: Last element.
- `-2`: Second-last, etc.
Useful for end-access without `len()`.

**Error Handling**:
```python
try:
    print(fruits[3])  # IndexError
except IndexError:
    print("Index out of range")
```

#### Length of List
Use the built-in `len()` function to get the number of elements.
- **Syntax**: `length = len(my_list)`
- Time complexity: O(1) (stored internally).

**Example**:
```python
numbers = [10, 20, 30, 40]
print(len(numbers))  # 4

# With empty list
print(len([]))  # 0
```

**Use Case**: Loop conditions or validation.
```python
if len(numbers) > 0:
    print("Not empty")
```

#### Indexing and Slicing of List
- **Indexing**: Access single element by position.
- **Slicing**: Extract a sublist (shallow copy) using `start:end:step`.
  - `start`: Inclusive (default 0).
  - `end`: Exclusive (default len(list)).
  - `step`: Increment (default 1; negative for reverse).
  - Returns new list; doesn't modify original.

**Example - Indexing**:
```python
lst = [0, 1, 2, 3, 4, 5]
print(lst[2])  # 2
print(lst[-3])  # 3
```

**Example - Slicing**:
```python
lst = [0, 1, 2, 3, 4, 5]

# Subset
print(lst[1:4])  # [1, 2, 3] (from index 1 to 3)

# Full copy
print(lst[:])  # [0, 1, 2, 3, 4, 5]

# Every second element
print(lst[::2])  # [0, 2, 4]

# Reverse
print(lst[::-1])  # [5, 4, 3, 2, 1, 0]

# From end
print(lst[-3:])  # [3, 4, 5]
print(lst[:-2])  # [0, 1, 2, 3]
```

**Advanced Slicing**:
- Step -2: `lst[:: -2]` → even reverse indices.
- Assign to slice: `lst[1:3] = [99, 88]` modifies in place (size can change).

**Notes**: Slicing is efficient (O(k) where k is slice length). Use for safe sublist extraction without errors.

#### Traverse the List
Iterate over elements using a `for` loop (most common), while indices with `range(len())`, or enumerate for index-value pairs.
- Traversing doesn't modify unless using indices.

**Example - For Loop (Element-Wise)**:
```python
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)  # apple \n banana \n cherry
```

**Example - With Indices**:
```python
for i in range(len(fruits)):
    print(f"{i}: {fruits[i]}")  # 0: apple \n etc.
```

**Example - Enumerate (Index and Value)**:
```python
for index, fruit in enumerate(fruits, start=1):  # start optional
    print(f"{index}: {fruit}")  # 1: apple \n etc.
```

**While Loop** (Less Common):
```python
i = 0
while i < len(fruits):
    print(fruits[i])
    i += 1
```

**Use Case**: Summing elements: `total = sum(fruit for fruit in numbers)` (generator for efficiency).

#### Compare the List
Compare lists using `==` (element-wise equality) or `!=`. Order and types matter.
- `==` checks if lengths match and elements are equal sequentially.
- For identity (same object): Use `is`.
- Other comparisons (`<`, `>`) lexicographical if lengths differ.

**Example**:
```python
list1 = [1, 2, 3]
list2 = [1, 2, 3]
list3 = [1, 2, 4]
list4 = [3, 2, 1]

print(list1 == list2)  # True (equal content)
print(list1 == list3)  # False (different elements)
print(list1 is list2)  # False (different objects)
print(list1 < list4)  # True ([1,2,3] < [3,2,1] lexicographically: 1<3)

# Mixed types
print([1, "a"] == [1, "a"])  # True
```

**Notes**:
- Nested lists compare recursively.
- Use `all()` or loops for custom comparisons (e.g., subset check).

#### Joining the List
"Joining" typically means concatenating lists with `+` or merging with methods like `extend()`. For string lists, use `str.join()` to create a single string.
- `+`: Creates new list (O(n+m) time).

**Example - List Concatenation**:
```python
list_a = [1, 2]
list_b = [3, 4]
joined = list_a + list_b  # [1, 2, 3, 4]
print(joined)

# Multiple
more = [0] + list_a + list_b  # [0, 1, 2, 3, 4]
```

**Example - String Join**:
```python
words = ["Hello", "World", "Python"]
sentence = " ".join(words)  # "Hello World Python"
print(sentence)

# With delimiter
csv = ",".join(words)  # "Hello,World,Python"
```

**Notes**:
- `join()` works only on iterables of strings; convert others with `str()`.
- For efficiency with many lists: Use `sum([list_a, list_b], [])` or `itertools.chain()`.

#### Replication of List
Replicate (repeat) a list using the `*` operator. Creates shallow copies of elements.
- **Syntax**: `replicated = original * n`
- Useful for padding or initializations.

**Example**:
```python
base = [1, 2]
doubled = base * 2  # [1, 2, 1, 2]
tripled = base * 3  # [1, 2, 1, 2, 1, 2]

# Empty * n = empty
print([] * 5)  # []

# Single element
print([0] * 3)  # [0, 0, 0]
```

**Notes**:
- Modifying replicated mutable elements affects all (shallow).
- Time: O(n * k) where k is replication factor.

#### Making the True Copy of List
A "true copy" means a deep or independent copy to avoid reference issues. Assignment (`a = b`) or slicing (`a = b[:]`) creates shallow copies.
- **Shallow Copy**: Copies list but shares mutable elements (use `copy()`, `[:]`, `list()`).
- **Deep Copy**: Copies nested mutables recursively (use `copy.deepcopy()`).

**Example - Shallow Copy**:
```python
original = [1, 2, [3, 4]]
shallow = original.copy()  # or original[:], list(original)

shallow[0] = 99  # original unchanged: [1, 2, [3, 4]]
shallow[2][0] = 33  # original affected: [1, 2, [33, 4]] (shared inner list)
```

**Example - Deep Copy** (from `copy` module):
```python
import copy
deep = copy.deepcopy(original)
deep[2][0] = 44  # original unchanged: [1, 2, [33, 4]]
```

**When to Use**:
- Shallow: Flat lists or immutable elements.
- Deep: Nested mutables (e.g., list of lists).

**Notes**: `id(original) != id(copy)` confirms new object.

#### index(), append() and extend()
These are key methods for searching and adding elements.

- **`index(value, start=0, end=None)`**: Returns first index of value. Raises `ValueError` if not found. O(n) time.
- **`append(item)`**: Adds single item to end. O(1) amortized.
- **`extend(iterable)`**: Adds all elements from iterable to end. Like repeated append.

**Example**:
```python
lst = [10, 20, 30, 20]

# index
print(lst.index(20))  # 1 (first occurrence)
print(lst.index(20, 2))  # 3 (from index 2)

# append
lst.append(40)  # [10, 20, 30, 20, 40]

# extend
lst.extend([50, 60])  # [10, 20, 30, 20, 40, 50, 60]
lst.extend("ab")  # Adds 'a', 'b': [..., 50, 60, 'a', 'b']
```

**Use Case**: Building lists dynamically: `data.extend(user_input.split())`.

#### insert(), pop(), popitem()
- **`insert(index, item)`**: Inserts item at index (shifts rest right). O(n) time.
- **`pop(index=-1)`**: Removes and returns item at index (default end). O(n) for middle, O(1) end.
- **`popitem()`**: For dicts only (removes last key-value). Not for lists—use `pop()`.

**Example**:
```python
lst = [10, 20, 30]

# insert
lst.insert(1, 15)  # [10, 15, 20, 30]
lst.insert(0, 5)  # [5, 10, 15, 20, 30]

# pop
last = lst.pop()  # 30; lst=[5,10,15,20]
middle = lst.pop(1)  # 10; lst=[5,15,20]

# popitem not applicable
```

**Notes**: Avoid frequent inserts/pops in middle for large lists (use collections.deque).

#### del and clear()
- **`del`**: Deletes by index, slice, or entire list. No return value.
- **`clear()`**: Empties list in place (sets length to 0).

**Example**:
```python
lst = [1, 2, 3, 4, 5]

# del single
del lst[1]  # [1, 3, 4, 5]

# del slice
del lst[1:3]  # [1, 5]

# del entire
del lst  # lst unbound (NameError if accessed)

# clear
new_lst = [10, 20]
new_lst.clear()  # []; original object reused
```

**Notes**:
- `del` on slice modifies in place.
- `clear()` faster than `lst = []` (reuses memory).

#### count(), reverse(), sort and sorted
- **`count(value)`**: Returns occurrences of value. O(n).
- **`reverse()`**: Reverses in place. O(n).
- **`sort(key=None, reverse=False)`**: Sorts in place. O(n log n). Stable.
- **`sorted(iterable, key=None, reverse=False)`**: Returns new sorted list. Same options.

**Example**:
```python
nums = [3, 1, 4, 1, 5, 9]

# count
print(nums.count(1))  # 2

# reverse
nums.reverse()  # [9, 5, 1, 4, 1, 3]

# sort in place
words = ["banana", "apple", "cherry"]
words.sort()  # ['apple', 'banana', 'cherry']
words.sort(reverse=True)  # ['cherry', 'banana', 'apple']

# sorted new list
sorted_nums = sorted(nums)  # [1, 1, 3, 4, 5, 9]; nums unchanged
sorted_words = sorted(words, key=len)  # By length: ['apple', 'banana', 'cherry'] (5,6,7)

# Custom key
people = [("Alice", 25), ("Bob", 30)]
sorted_people = sorted(people, key=lambda x: x[1])  # By age: [('Alice',25), ('Bob',30)]
```

**Notes**:
- `sort()` modifies; `sorted()` doesn't.
- Key function: Lambda or function taking one arg.
- For strings: Case-sensitive; use `key=str.lower`.

#### Two Dimensional List
A 2D list simulates matrices/tables. Access via `row[col]`. Create manually, with loops, or comprehensions.
- Rows: Outer list elements.
- Columns: Consistent inner list lengths for rectangular.

**Example - Creation**:
```python
# Manual
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# Comprehension
matrix_comp = [[i*j for j in range(3)] for i in range(1, 4)]  # [[1*0,1*1,1*2], ...] Wait, adjust:
# Better: [[row * col for col in range(1,4)] for row in range(1,4)] → [[1,2,3],[2,4,6],[3,5,9]]? No.
# Standard: [[0]*3 for _ in range(3)]  # Empty 3x3: [[0,0,0], ...]

# Jagged (uneven rows OK)
jagged = [[1,2], [3,4,5], [6]]
```

**Accessing/Traversing**:
```python
print(matrix[1][2])  # 6

# Row-wise
for row in matrix:
    print(row)  # [1,2,3] \n etc.

# Element-wise
for row in range(len(matrix)):
    for col in range(len(matrix[row])):
        print(matrix[row][col], end=' ')  # 1 2 3 \n 4 5 6 \n etc.

# With enumerate
for i, row in enumerate(matrix):
    for j, val in enumerate(row):
        print(f"({i},{j}): {val}")
```

**Operations**:
- Transpose: `list(map(list, zip(*matrix)))` → [[1,4,7],[2,5,8],[3,6,9]]
- Sum rows: `[sum(row) for row in matrix]` → [6,15,24]
- Modify: `matrix[0][0] = 99`

**Use Cases**: Image processing (pixels), spreadsheets, graphs.
- Libraries: NumPy for efficient multi-dim arrays (beyond basic lists).

