# M7: Tuples in Python

### Tuples are immutable, ordered collections of items in Python, similar to lists but unchangeable after creation. This immutability makes tuples hashable (usable as dictionary keys or set elements), memory-efficient for fixed data, and ideal for representing heterogeneous data like coordinates or database records. Tuples are defined using parentheses `()` and support indexing, slicing, and unpacking. They are lighter than lists (no method overhead) and enforce data integrity by preventing accidental modifications.

### Unlike lists, tuples have no methods for adding/removing elements—use them for "read-only" sequences. Internally, tuples store fixed-size arrays, offering O(1) access time.

## Creation of Tuple
Create tuples using parentheses `()`, separating elements with commas. Elements can be of any type, including mixed. The parentheses are optional but recommended for clarity.
- **Syntax**: `my_tuple = (element1, element2, ...)`
- Commas are essential; trailing commas are allowed.

**Example**:
```python
# Basic tuple with mixed types
coordinates = (10, 20.5, "point")
print(coordinates)  # (10, 20.5, 'point')

# Integer tuple
primes = (2, 3, 5, 7, 11)
```

**Notes**:
- Tuples can be created without `()`, e.g., `t = 1, 2, 3` (packing), but use `()` for expressions.
- Immutability: `primes[0] = 4` raises `TypeError`.
- Use tuple comprehension? No direct, but `tuple(x for x in range(3))` works.

#### Empty Tuple
An empty tuple has no elements and is created with empty parentheses. It's useful for placeholders or as default return values.
- **Syntax**: `empty_tuple = ()`

**Example**:
```python
empty = ()
print(empty)  # ()
print(len(empty))  # 0
print(type(empty))  # <class 'tuple'>

# In functions
def get_default():
    return ()  # Empty tuple as default
```

**Notes**:
- `bool(empty)` is `False`, like empty lists.
- Rarely used alone; often in unpacking: `a, *rest = ()` → `rest=[]` (but for tuples, `rest=()`).

#### Single Element
A single-item tuple requires a trailing comma to distinguish from a parenthesized expression (e.g., `(5)` is just 5).
- **Syntax**: `single_tuple = (element,)`

**Example**:
```python
single_int = (42,)  # Correct
print(single_int)  # (42,)
print(type(single_int))  # <class 'tuple'>

# Without comma: (42) is int 42
parenthesized = (42)
print(type(parenthesized))  # <class 'int'>

# String example
single_str = ("hello",)
```

**Notes**:
- Unpack: `val, = single_int` → `val=42`.
- Common error: Forgetting comma leads to wrong type.

#### Create Tuple from Existing Sequence
Use the `tuple()` constructor to convert iterables (lists, strings, sets, ranges) into tuples. This is explicit and preserves order where applicable.
- **Syntax**: `new_tuple = tuple(iterable)`
- Non-iterables raise `TypeError`.

**Example**:
```python
# From list
num_list = [1, 2, 3]
num_tuple = tuple(num_list)  # (1, 2, 3)

# From string
chars = tuple("abc")  # ('a', 'b', 'c')

# From range
evens = tuple(range(0, 6, 2))  # (0, 2, 4)

# From set (order not guaranteed pre-3.7, but insertion order since)
s = {3, 1, 2}
t = tuple(s)  # (3, 1, 2) or similar

# From another tuple (identity preserved if same)
t2 = tuple(num_tuple)  # Same as num_tuple
```

**Notes**:
- Efficient for one-time conversions; `tuple(list)` is common for immutability.
- For generators: `tuple(gen)` consumes it once.

#### Nested Tuple
Nested tuples allow hierarchical structures, like lists but immutable. Create by including tuples as elements.
- Useful for multi-dimensional data, e.g., matrices or trees.

**Example**:
```python
# 2D nested tuple (immutable matrix)
matrix = ((1, 2, 3), (4, 5, 6), (7, 8, 9))

# Deeper nesting
tree = ((1, (2, 3)), (4,))

print(matrix)  # ((1, 2, 3), (4, 5, 6), (7, 8, 9))
```

**Accessing** (detailed next): `matrix[1][2]` → 6.
**Notes**:
- All levels immutable: Can't change inner elements.
- Unpacking nested: `a, (b, c) = (1, (2, 3))` → a=1, b=2, c=3.

##  Accessing Tuples
Access elements by index using square brackets `[]`. Zero-indexed, supports negative indices. No modification allowed.
- **Syntax**: `element = my_tuple[index]`
- Out-of-bounds: `IndexError`.

**Example**:
```python
colors = ("red", "green", "blue")
print(colors[0])  # red (first)
print(colors[-1])  # blue (last)
print(colors[1])  # green

# Nested access
print(matrix[0][2])  # 3 (first row, third column)
```

**Slicing** (inherited from sequences):
```python
print(colors[1:])  # ('green', 'blue')
print(colors[::-1])  # ('blue', 'green', 'red') (reverse)
```

**Notes**:
- Slicing returns new tuple (shallow copy).
- For safety: Use `getattr` or try-except for dynamic access.

## Traverse Tuple
Iterate using `for` loops (element-wise), `range(len())` for indices, or `enumerate` for both. Since immutable, traversal is read-only.
- Efficient: O(n) time.

**Example - For Loop (Elements)**:
```python
days = ("Mon", "Tue", "Wed", "Thu", "Fri")
for day in days:
    print(day)  # Mon \n Tue \n etc.
```

**Example - With Indices**:
```python
for i in range(len(days)):
    print(f"Index {i}: {days[i]}")  # Index 0: Mon \n etc.
```

**Example - Enumerate**:
```python
for index, day in enumerate(days, start=1):
    print(f"{index}: {day}")  # 1: Mon \n etc.
```

**Nested Traversal**:
```python
for row in matrix:
    for elem in row:
        print(elem, end=' ')  # 1 2 3 4 5 6 7 8 9
```

**Notes**:
- While loops possible but less Pythonic.
- Use `iter(tuple)` for manual iteration if needed.

## Join
"Join" for tuples means concatenation using `+` (creates new tuple) or unpacking into another structure. No in-place join like lists. For string tuples, use `str.join()`.
- `+`: O(n+m) time, new object.

**Example - Concatenation**:
```python
tuple1 = (1, 2)
tuple2 = (3, 4)
joined = tuple1 + tuple2  # (1, 2, 3, 4)

# Multiple
extended = (0,) + tuple1 + (5,)  # (0, 1, 2, 5)

# Empty + t = t
print(() + colors)  # ('red', 'green', 'blue')
```

**Example - String Join**:
```python
words = ("Hello", "World")
sentence = " ".join(words)  # "Hello World"
print(sentence)

# Delimiter
csv = ",".join(words)  # "Hello,World"
```

**Unpacking for Join**:
```python
# Into list then join
combined = [*tuple1, *tuple2]  # [1,2,3,4] (unpack with *)
print(" ".join(map(str, combined)))  # "1 2 3 4"
```

**Notes**:
- No `extend()`; use `+` or `*` for repetition: `(1,2) * 2` → (1,2,1,2).
- For efficiency with many: `tuple(itertools.chain(t1, t2))` from `itertools`.

## len(), max(), min()
These built-ins work on tuples like other sequences. Require comparable elements (e.g., all numbers or strings).
- **`len(tuple)`**: Number of elements. O(1).
- **`max(tuple)`**: Largest element (or with `key`). Raises `ValueError` if empty.
- **`min(tuple)`**: Smallest element (similar).

**Example**:
```python
nums = (10, 3, 7, 20, 5)
print(len(nums))  # 5

print(max(nums))  # 20
print(min(nums))  # 3

# Strings (lexicographical)
letters = ('z', 'a', 'c')
print(max(letters))  # 'z'
print(min(letters))  # 'a'

# With key (custom comparison)
people = (('Alice', 25), ('Bob', 30), ('Charlie', 20))
oldest = max(people, key=lambda p: p[1])  # ('Bob', 30)
print(oldest)

# Empty: ValueError
try:
    max(())
except ValueError:
    print("Empty tuple")
```

**Nested**:
```python
print(max(matrix, key=lambda row: sum(row)))  # Row with max sum: (4,5,6) sum=15
```

**Notes**:
- For mixed types: May raise `TypeError` (e.g., max(1, 'a')).
- Key function: Like sorted, for complex comparisons.
- Sum: `sum(nums)` works for numerics.

