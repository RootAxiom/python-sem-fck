# M5: Functions in Python

### Functions are reusable blocks of code that perform a specific task. They promote modularity, reduce redundancy, and make code easier to read and maintain. In Python, functions are first-class objects, meaning they can be passed as arguments, returned from other functions, and assigned to variables.

## Difference Between Function and Method
- **Function**: A standalone procedure defined outside any class using the `def` keyword. It operates independently and is called directly by its name. Functions are useful for general-purpose utilities that don't rely on object state.
  - Example: A function to calculate the square of a number.
- **Method**: A function that is defined inside a class and operates on instances (objects) of that class. It is bound to the object and typically takes `self` as the first parameter (for instance methods). Methods encapsulate behavior with data.
  - Example: A `list.append()` method modifies a list object.

**Key Differences**:
| Aspect          | Function                          | Method                            |
|-----------------|-----------------------------------|-----------------------------------|
| **Definition**  | Outside class: `def func():`     | Inside class: `def method(self):` |
| **Invocation**  | `func(arg)`                      | `obj.method(arg)`                 |
| **Binding**     | Not tied to an object            | Tied to class/object instance     |
| **Use Case**    | Global utilities (e.g., math ops)| Object-specific behavior (e.g., data manipulation) |

Functions can mimic methods if defined as standalone, but methods leverage object-oriented principles.

#### Define a Function
To define a function:
1. Use `def` followed by the function name (lowercase with underscores for readability, per PEP 8).
2. Optionally, add parameters in parentheses.
3. End with a colon `:`.
4. Indent the function body (typically 4 spaces).
5. The body can include statements, loops, conditionals, etc.

**Basic Syntax**:
```python
def function_name(parameter1, parameter2 = default_value):
    # Function body
    # Optional: return value
    pass  # Placeholder for empty body
```

**Example**:
```python
def calculate_area(length, width):
    area = length * width
    print(f"The area is {area}")
    # Implicit return None if no return statement
```

Functions can be empty (using `pass`), but it's good practice to add a docstring for documentation:
```python
def calculate_area(length, width):
    """
    Calculates the area of a rectangle.
    
    Args:
        length (float): Length of the rectangle.
        width (float): Width of the rectangle.
    
    Returns:
        float: The computed area.
    """
    return length * width
```

#### Calling a Function
Invoke the function by its name followed by parentheses containing arguments (values passed to parameters).
- Arguments must match the number and order of parameters (unless using defaults or keywords).
- Calling executes the function body.

**Example**:
```python
# Define first
def greet(name):
    print(f"Hello, {name}!")

# Call
greet("World")  # Output: Hello, World!
greet("Python Programmer")  # Output: Hello, Python Programmer!
```

Multiple calls reuse the code without redefinition. If called before definition, Python raises a `NameError`.

#### Return Results from Function
The `return` statement exits the function and sends a value back to the caller. Without `return`, the function returns `None` by default.
- Use `return value` to output a single value, expression, or object.
- Early `return` can skip remaining code for efficiency.

**Example**:
```python
def add_numbers(a, b):
    sum_result = a + b
    return sum_result  # Or directly: return a + b

result = add_numbers(10, 20)
print(result)  # Output: 30

# Multiple returns based on condition
def is_even(n):
    if n % 2 == 0:
        return True
    return False  # Equivalent to: return n % 2 == 0

print(is_even(4))  # True
```

**Best Practice**: Always return values for computations to enable chaining or further processing.

#### Return Multiple Values from Function
Python allows returning multiple values as a tuple (or any iterable), which can be unpacked on the caller's side.
- This is efficient and readable, simulating multiple returns without lists or dicts.

**Example**:
```python
def get_coordinates():
    return 10, 20  # Returns tuple (10, 20)

x, y = get_coordinates()  # Unpacking
print(f"X: {x}, Y: {y}")  # X: 10, Y: 20

# Or return as named tuple for clarity (from collections import namedtuple)
from collections import namedtuple
Point = namedtuple('Point', ['x', 'y'])

def get_point():
    return Point(10, 20)

p = get_point()
print(p.x, p.y)  # 10 20
```

**Advanced**: Return a dictionary for named multiple values.
```python
def get_stats(numbers):
    return {'sum': sum(numbers), 'avg': sum(numbers)/len(numbers), 'max': max(numbers)}

stats = get_stats([1, 2, 3, 4])
print(stats['avg'])  # 2.5
```

#### Formal and Actual Arguments
- **Formal Arguments (Parameters)**: Placeholders in the function definition. They act as local variables during execution.
  - Example: In `def func(x, y):`, `x` and `y` are formal.
- **Actual Arguments**: Real values passed during the call. They are assigned to formals.
  - Example: In `func(5, 10)`, `5` and `10` are actual.

**Mapping**:
| Call                  | Formal Assignment |
|-----------------------|-------------------|
| `func(5, 10)`        | x=5, y=10        |
| `func(a=5, b=10)`    | x=5, y=10 (named)|

Formals are scoped locally; changes don't affect actuals (unless mutable objects like lists).

#### Positional Arguments
Arguments passed in the exact order of parameters. Python matches them left-to-right.
- Simple but error-prone if order is forgotten.

**Example**:
```python
def describe_person(name, age, city):
    print(f"{name} is {age} years old and lives in {city}.")

describe_person("Alice", 25, "New York")  # Alice is 25 years old and lives in New York.
# describe_person(25, "Alice", "NY")  # Wrong: Alice is 25... (name=25, incorrect)
```

**Limitation**: Order must match; use keywords for flexibility.

#### Default Arguments
Assign default values to parameters, making them optional. Defaults are evaluated once at definition time.
- Place defaults after non-defaults.
- Mutable defaults (e.g., lists) can cause bugs if modified.

**Example**:
```python
def describe_person(name, age, city="Unknown"):
    print(f"{name} is {age} years old and lives in {city}.")

describe_person("Alice", 25)  # Alice is 25 years old and lives in Unknown.
describe_person("Bob", 30, "London")  # Overrides default
```

**Pitfall Example (Mutable Default)**:
```python
def append_to_list(item, my_list=[]):  # Bad: [] shared across calls
    my_list.append(item)
    return my_list

print(append_to_list(1))  # [1]
print(append_to_list(2))  # [1, 2]  # Unexpected!
```
**Fix**: Use `None` and initialize inside.
```python
def append_to_list(item, my_list=None):
    if my_list is None:
        my_list = []
    my_list.append(item)
    return my_list
```

#### Keyword Arguments
Pass arguments by parameter name, ignoring order. Useful for clarity in functions with many parameters.
- Can mix with positional (keywords after positionals).
- Defaults can be overridden.

**Example**:
```python
def describe_person(name, age, city="Unknown"):
    print(f"{name} is {age} years old and lives in {city}.")

describe_person(age=25, name="Alice", city="NYC")  # Works regardless of order
describe_person("Bob", city="LA", age=30)  # Mixed: positional first
```

**Benefits**: Self-documenting calls; prevents order errors.

#### Variable Length Arguments
Handle arbitrary numbers of arguments without fixed parameters.
- `*args`: Captures positional args as a tuple. For "extra" positionals.
- `**kwargs`: Captures keyword args as a dict. For "extra" keywords.
- Use alone or with fixed params (extras come after).

**Example with *args**:
```python
def sum_all(*args):  # args = (1, 2, 3, ...)
    return sum(args)

print(sum_all(1, 2, 3, 4))  # 10
print(sum_all())  # 0 (empty tuple)

# With fixed params
def greet(greeting, *names):
    for name in names:
        print(f"{greeting}, {name}!")

greet("Hi", "Alice", "Bob")  # Hi, Alice! \n Hi, Bob!
```

**Example with **kwargs**:
```python
def print_info(**kwargs):  # kwargs = {'key': 'value', ...}
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="Alice", age=25, city="NYC")
# name: Alice
# age: 25
# city: NYC

# Mixed
def mixed_example(required, *args, **kwargs):
    print(f"Required: {required}")
    print(f"Args: {args}")
    print(f"Kwargs: {kwargs}")

mixed_example(1, 2, 3, option1="A", option2="B")
# Required: 1
# Args: (2, 3)
# Kwargs: {'option1': 'A', 'option2': 'B'}
```

**Unpacking**: Use `*` for iterables into positionals, `**` for dicts into keywords.
```python
numbers = [1, 2, 3]
print(sum(*numbers))  # Unpacks to sum(1, 2, 3)

data = {'name': 'Alice', 'age': 25}
describe_person(**data)  # Calls with keywords
```

#### Local and Global Variables
Variables have scopes determining visibility and lifetime.
- **Local Variables**: Defined inside a function; accessible only within it. Created on entry, destroyed on exit. Safer, avoids side effects.
  - Example: In `def func(): x = 5`, `x` is local.
- **Global Variables**: Defined at module level (top); accessible everywhere unless shadowed by local. Use sparingly to avoid bugs.
  - To modify global inside function, declare `global var_name`.

**Example**:
```python
global_var = 100  # Global

def modify_local():
    local_var = 10  # Local
    print(f"Local: {local_var}")
    print(f"Global (unchanged): {global_var}")

def modify_global():
    global global_var
    global_var = 200  # Now modifies global
    print(f"Modified Global: {global_var}")

modify_local()  # Local: 10 \n Global: 100
print(global_var)  # 100
modify_global()  # Modified Global: 200
print(global_var)  # 200
```

**Scope Resolution (LEGB Rule)**: Local > Enclosing (nested funcs) > Global > Built-in.
- Shadowing: Local `x` hides global `x`.
- Nonlocal (for nested funcs): `nonlocal var` to modify enclosing scope.

**Best Practice**: Minimize globals; pass as parameters instead.

#### Recursive Function
A function that calls itself to solve smaller subproblems. Essential for tree traversals, factorials, etc.
- **Base Case**: Condition to stop recursion (avoids infinite loop).
- **Recursive Case**: Calls self with modified argument (progress toward base).
- Python limits recursion depth (~1000 calls) to prevent stack overflow.

**Example: Factorial**:
```python
def factorial(n):
    if n <= 1:  # Base case
        return 1
    return n * factorial(n - 1)  # Recursive: n=5 -> 5 * factorial(4) -> ... -> 1

print(factorial(5))  # 120
# Trace: factorial(5) = 5*24=120; factorial(4)=4*6=24; etc.
```

**Example: Fibonacci (Inefficient; better with memoization)**:
```python
def fibonacci(n):
    if n <= 1:  # Base
        return n
    return fibonacci(n-1) + fibonacci(n-2)  # Recursive

print(fibonacci(6))  # 8 (0,1,1,2,3,5,8)
```

**Tail Recursion Optimization**: Python doesn't optimize, but base case prevents deep stacks. For large n, use iterative loops.

**Pros/Cons**:
| Pros                  | Cons                          |
|-----------------------|-------------------------------|
| Elegant for hierarchies | Risk of stack overflow       |
| Natural divide-conquer | Slower than iteration (calls)|

#### Using Lambdas with filter()
- **Lambda**: Anonymous (nameless) function for short, one-off use. Syntax: `lambda arguments: expression`.
  - No statements (only expressions); single return.
  - Replaces simple functions for conciseness.

**filter(function, iterable)**: Applies function to each item; keeps those returning True. Returns iterator (convert to list/tuple).

**Example**:
```python
numbers = [1, 2, 3, 4, 5, 6]

# Lambda with filter: Even numbers
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens)  # [2, 4, 6]

# Strings longer than 3 chars
words = ["cat", "elephant", "dog", "book"]
long_words = list(filter(lambda w: len(w) > 3, words))
print(long_words)  # ['elephant', 'book']

# Without lambda (named function)
def is_even(x):
    return x % 2 == 0
evens_named = list(filter(is_even, numbers))
```

**Advanced**: Chain with other functionals.
```python
# Positive numbers greater than 10
data = [-5, 12, 3, 15, -1, 20]
positives_gt10 = list(filter(lambda x: x > 10 and x > 0, data))  # [12, 15, 20]
```

#### Lambdas with map()
**map(function, iterable)**: Applies function to each item; returns new iterator with results.

**Example**:
```python
numbers = [1, 2, 3, 4]

# Square each
squares = list(map(lambda x: x ** 2, numbers))
print(squares)  # [1, 4, 9, 16]

# Add 10 to each
plus_ten = list(map(lambda x: x + 10, numbers))
print(plus_ten)  # [11, 12, 13, 14]

# Multiple iterables
names = ["alice", "bob"]
capitalized = list(map(lambda name: name.capitalize(), names))
print(capitalized)  # ['Alice', 'Bob']

# With two lists
list1 = [1, 2]
list2 = [10, 20]
sums = list(map(lambda a, b: a + b, list1, list2))
print(sums)  # [11, 22]
```

**Comparison: map vs filter**:
| Function | Purpose                  | Output                          |
|----------|--------------------------|---------------------------------|
| **map**  | Transform each element  | New values from function        |
| **filter**| Select based on condition| Subset of original (truthy)    |

**Best Practices for Lambdas**:
- Use for simple ops (one-liners).
- Avoid for complex logic (use def for readability).
- Common in list comprehensions alternative: `[x**2 for x in numbers]` vs `map(lambda x: x**2, numbers)`.

